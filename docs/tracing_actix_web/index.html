<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`tracing-actix-web` provides `TracingLogger`, a middleware to collect telemetry data from applications built on top of the `actix-web` framework."><title>tracing_actix_web - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="tracing_actix_web" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.1 (eb26296b5 2023-08-03)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../tracing_actix_web/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../tracing_actix_web/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate tracing_actix_web</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.7.9</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">tracing_actix_web</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/tracing_actix_web/lib.rs.html#1-319">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>tracing-actix-web</code> provides <a href="struct.TracingLogger.html" title="struct tracing_actix_web::TracingLogger"><code>TracingLogger</code></a>, a middleware to collect telemetry data from applications
built on top of the <a href="https://docs.rs/actix-web/4.0.0-beta.13/actix_web/index.html"><code>actix-web</code></a> framework.</p>
<blockquote>
<p><code>tracing-actix-web</code> was initially developed for the telemetry chapter of <a href="https://zero2prod.com">Zero to Production In Rust</a>, a hands-on introduction to backend development using the Rust programming language.</p>
</blockquote>
<h2 id="getting-started"><a href="#getting-started">Getting started</a></h2><h3 id="how-to-install"><a href="#how-to-install">How to install</a></h3>
<p>Add <code>tracing-actix-web</code> to your dependencies:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
# ...
tracing-actix-web = &quot;0.7&quot;
tracing = &quot;0.1&quot;
actix-web = &quot;4&quot;
</code></pre></div>
<p><code>tracing-actix-web</code> exposes three feature flags:</p>
<ul>
<li><code>opentelemetry_0_13</code>: attach <a href="https://github.com/open-telemetry/opentelemetry-rust">OpenTelemetry</a>’s context to the root span using <code>opentelemetry</code> 0.13;</li>
<li><code>opentelemetry_0_14</code>: same as above but using <code>opentelemetry</code> 0.14;</li>
<li><code>opentelemetry_0_15</code>: same as above but using <code>opentelemetry</code> 0.15;</li>
<li><code>opentelemetry_0_16</code>: same as above but using <code>opentelemetry</code> 0.16;</li>
<li><code>opentelemetry_0_17</code>: same as above but using <code>opentelemetry</code> 0.17;</li>
<li><code>opentelemetry_0_18</code>: same as above but using <code>opentelemetry</code> 0.18;</li>
<li><code>opentelemetry_0_19</code>: same as above but using <code>opentelemetry</code> 0.19;</li>
<li><code>opentelemetry_0_20</code>: same as above but using <code>opentelemetry</code> 0.20;</li>
<li><code>opentelemetry_0_21</code>: same as above but using <code>opentelemetry</code> 0.21;</li>
<li><code>emit_event_on_error</code>: emit a <a href="../tracing/index.html" title="mod tracing"><code>tracing</code></a> event when request processing fails with an error (enabled by default).</li>
<li><code>uuid_v7</code>: use the UUID v7 implementation inside <a href="struct.RequestId.html" title="struct tracing_actix_web::RequestId"><code>RequestId</code></a> instead of UUID v4 (disabled by default).</li>
</ul>
<h3 id="quickstart"><a href="#quickstart">Quickstart</a></h3>
<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_web::{App, web, HttpServer};
<span class="kw">use </span>tracing_actix_web::TracingLogger;

<span class="kw">let </span>server = HttpServer::new(|| {
    App::new()
        <span class="comment">// Mount `TracingLogger` as a middleware
        </span>.wrap(TracingLogger::default())
        .service( <span class="comment">/*  */ </span>)
});</code></pre></div>
<p>Check out <a href="https://github.com/LukeMathWalker/tracing-actix-web/tree/main/examples">the examples on GitHub</a> to get a taste of how <a href="struct.TracingLogger.html" title="struct tracing_actix_web::TracingLogger"><code>TracingLogger</code></a> can be used to observe and monitor your
application.</p>
<h2 id="from-zero-to-hero-a-crash-course-in-observability"><a href="#from-zero-to-hero-a-crash-course-in-observability">From zero to hero: a crash course in observability</a></h2><h3 id="tracing-who-art-thou"><a href="#tracing-who-art-thou"><code>tracing</code>: who art thou?</a></h3>
<p><a href="struct.TracingLogger.html" title="struct tracing_actix_web::TracingLogger"><code>TracingLogger</code></a> is built on top of <a href="../tracing/index.html" title="mod tracing"><code>tracing</code></a>, a modern instrumentation framework with
<a href="https://github.com/tokio-rs/tracing#related-crates">a vibrant ecosystem</a>.</p>
<p><code>tracing-actix-web</code>’s documentation provides a crash course in how to use <a href="../tracing/index.html" title="mod tracing"><code>tracing</code></a> to instrument an <code>actix-web</code> application.<br />
If you want to learn more check out <a href="https://www.lpalmieri.com/posts/2020-09-27-zero-to-production-4-are-we-observable-yet/">“Are we observable yet?”</a> -
it provides an in-depth introduction to the crate and the problems it solves within the bigger picture of <a href="https://docs.honeycomb.io/learning-about-observability/">observability</a>.</p>
<h3 id="the-root-span"><a href="#the-root-span">The root span</a></h3>
<p><a href="../tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>tracing::Span</code></a> is the key abstraction in <a href="../tracing/index.html" title="mod tracing"><code>tracing</code></a>: it represents a unit of work in your system.<br />
A <a href="../tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>tracing::Span</code></a> has a beginning and an end. It can include one or more <strong>child spans</strong> to represent sub-unit
of works within a larger task.</p>
<p>When your application receives a request, <a href="struct.TracingLogger.html" title="struct tracing_actix_web::TracingLogger"><code>TracingLogger</code></a> creates a new span - we call it the <strong><a href="struct.RootSpan.html" title="struct tracing_actix_web::RootSpan">root span</a></strong>.<br />
All the spans created <em>while</em> processing the request will be children of the root span.</p>
<p><a href="../tracing/index.html" title="mod tracing"><code>tracing</code></a> empowers us to attach structured properties to a span as a collection of key-value pairs.<br />
Those properties can then be queried in a variety of tools (e.g. ElasticSearch, Honeycomb, DataDog) to
understand what is happening in your system.</p>
<h3 id="customisation-via-rootspanbuilder"><a href="#customisation-via-rootspanbuilder">Customisation via <code>RootSpanBuilder</code></a></h3>
<p>Troubleshooting becomes much easier when the root span has a <em>rich context</em> - e.g. you can understand most of what
happened when processing the request just by looking at the properties attached to the corresponding root span.</p>
<p>You might have heard of this technique as the <a href="https://stripe.com/blog/canonical-log-lines">canonical log line pattern</a>,
popularised by Stripe. It is more recently discussed in terms of <a href="https://www.honeycomb.io/blog/observability-a-manifesto/">high-cardinality events</a>
by Honeycomb and other vendors in the observability space.</p>
<p><a href="struct.TracingLogger.html" title="struct tracing_actix_web::TracingLogger"><code>TracingLogger</code></a> gives you a chance to use the very same pattern: you can customise the properties attached
to the root span in order to capture the context relevant to your specific domain.</p>
<p><a href="struct.TracingLogger.html#method.default" title="associated function tracing_actix_web::TracingLogger::default"><code>TracingLogger::default</code></a> is equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tracing_actix_web::{TracingLogger, DefaultRootSpanBuilder};

<span class="comment">// Two ways to initialise TracingLogger with the default root span builder
</span><span class="kw">let </span>default = TracingLogger::default();
<span class="kw">let </span>another_way = TracingLogger::&lt;DefaultRootSpanBuilder&gt;::new();</code></pre></div>
<p>We are delegating the construction of the root span to <a href="struct.DefaultRootSpanBuilder.html" title="struct tracing_actix_web::DefaultRootSpanBuilder"><code>DefaultRootSpanBuilder</code></a>.<br />
<a href="struct.DefaultRootSpanBuilder.html" title="struct tracing_actix_web::DefaultRootSpanBuilder"><code>DefaultRootSpanBuilder</code></a> captures, out of the box, several dimensions that are usually relevant when looking at an HTTP
API: method, version, route, etc. - check out its documentation for an extensive list.</p>
<p>You can customise the root span by providing your own implementation of the <a href="trait.RootSpanBuilder.html" title="trait tracing_actix_web::RootSpanBuilder"><code>RootSpanBuilder</code></a> trait.<br />
Let’s imagine, for example, that our system cares about a client identifier embedded inside an authorization header.
We could add a <code>client_id</code> property to the root span using a custom builder, <code>DomainRootSpanBuilder</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_web::body::MessageBody;
<span class="kw">use </span>actix_web::dev::{ServiceResponse, ServiceRequest};
<span class="kw">use </span>actix_web::Error;
<span class="kw">use </span>tracing_actix_web::{TracingLogger, DefaultRootSpanBuilder, RootSpanBuilder};
<span class="kw">use </span>tracing::Span;

<span class="kw">pub struct </span>DomainRootSpanBuilder;

<span class="kw">impl </span>RootSpanBuilder <span class="kw">for </span>DomainRootSpanBuilder {
    <span class="kw">fn </span>on_request_start(request: <span class="kw-2">&amp;</span>ServiceRequest) -&gt; Span {
        <span class="kw">let </span>client_id: <span class="kw-2">&amp;</span>str = <span class="macro">todo!</span>(<span class="string">&quot;Somehow extract it from the authorization header&quot;</span>);
        <span class="macro">tracing::info_span!</span>(<span class="string">&quot;Request&quot;</span>, client_id)
    }

    <span class="kw">fn </span>on_request_end&lt;B: MessageBody&gt;(_span: Span, _outcome: <span class="kw-2">&amp;</span><span class="prelude-ty">Result</span>&lt;ServiceResponse&lt;B&gt;, Error&gt;) {}
}

<span class="kw">let </span>custom_middleware = TracingLogger::&lt;DomainRootSpanBuilder&gt;::new();</code></pre></div>
<p>There is an issue, though: <code>client_id</code> is the <em>only</em> property we are capturing.<br />
With <code>DomainRootSpanBuilder</code>, as it is, we do not get any of that useful HTTP-related information provided by
<a href="struct.DefaultRootSpanBuilder.html" title="struct tracing_actix_web::DefaultRootSpanBuilder"><code>DefaultRootSpanBuilder</code></a>.</p>
<p>We can do better!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_web::body::MessageBody;
<span class="kw">use </span>actix_web::dev::{ServiceResponse, ServiceRequest};
<span class="kw">use </span>actix_web::Error;
<span class="kw">use </span>tracing_actix_web::{TracingLogger, DefaultRootSpanBuilder, RootSpanBuilder};
<span class="kw">use </span>tracing::Span;

<span class="kw">pub struct </span>DomainRootSpanBuilder;

<span class="kw">impl </span>RootSpanBuilder <span class="kw">for </span>DomainRootSpanBuilder {
    <span class="kw">fn </span>on_request_start(request: <span class="kw-2">&amp;</span>ServiceRequest) -&gt; Span {
        <span class="kw">let </span>client_id: <span class="kw-2">&amp;</span>str = <span class="macro">todo!</span>(<span class="string">&quot;Somehow extract it from the authorization header&quot;</span>);
        <span class="macro">tracing_actix_web::root_span!</span>(request, client_id)
    }

    <span class="kw">fn </span>on_request_end&lt;B: MessageBody&gt;(span: Span, outcome: <span class="kw-2">&amp;</span><span class="prelude-ty">Result</span>&lt;ServiceResponse&lt;B&gt;, Error&gt;) {
        DefaultRootSpanBuilder::on_request_end(span, outcome);
    }
}

<span class="kw">let </span>custom_middleware = TracingLogger::&lt;DomainRootSpanBuilder&gt;::new();</code></pre></div>
<p><a href="macro.root_span.html" title="macro tracing_actix_web::root_span"><code>root_span!</code></a> is a macro provided by <code>tracing-actix-web</code>: it creates a new span by combining all the HTTP properties tracked
by <a href="struct.DefaultRootSpanBuilder.html" title="struct tracing_actix_web::DefaultRootSpanBuilder"><code>DefaultRootSpanBuilder</code></a> with the custom ones you specify when calling it (e.g. <code>client_id</code> in our example).</p>
<p>We need to use a macro because <code>tracing</code> requires all the properties attached to a span to be declared upfront, when the span is created.<br />
You cannot add new ones afterwards. This makes it extremely fast, but it pushes us to reach for macros when we need some level of
composition.</p>
<p><a href="macro.root_span.html" title="macro tracing_actix_web::root_span"><code>root_span!</code></a> exposes more or less the same knob you can find on <code>tracing</code>’s <code>span!</code> macro. You can, for example, customise
the span level:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_web::body::MessageBody;
<span class="kw">use </span>actix_web::dev::{ServiceResponse, ServiceRequest};
<span class="kw">use </span>actix_web::Error;
<span class="kw">use </span>tracing_actix_web::{TracingLogger, DefaultRootSpanBuilder, RootSpanBuilder, Level};
<span class="kw">use </span>tracing::Span;

<span class="kw">pub struct </span>CustomLevelRootSpanBuilder;

<span class="kw">impl </span>RootSpanBuilder <span class="kw">for </span>CustomLevelRootSpanBuilder {
    <span class="kw">fn </span>on_request_start(request: <span class="kw-2">&amp;</span>ServiceRequest) -&gt; Span {
        <span class="kw">let </span>level = <span class="kw">if </span>request.path() == <span class="string">&quot;/health_check&quot; </span>{
            Level::DEBUG
        } <span class="kw">else </span>{
            Level::INFO
        };
        <span class="macro">tracing_actix_web::root_span!</span>(level = level, request)
    }

    <span class="kw">fn </span>on_request_end&lt;B: MessageBody&gt;(span: Span, outcome: <span class="kw-2">&amp;</span><span class="prelude-ty">Result</span>&lt;ServiceResponse&lt;B&gt;, Error&gt;) {
        DefaultRootSpanBuilder::on_request_end(span, outcome);
    }
}

<span class="kw">let </span>custom_middleware = TracingLogger::&lt;CustomLevelRootSpanBuilder&gt;::new();</code></pre></div>
<h3 id="the-rootspan-extractor"><a href="#the-rootspan-extractor">The <code>RootSpan</code> extractor</a></h3>
<p>It often happens that not all information about a task is known upfront, encoded in the incoming request.<br />
You can use the <a href="struct.RootSpan.html" title="struct tracing_actix_web::RootSpan"><code>RootSpan</code></a> extractor to grab the root span in your handlers and attach more information
to your root span as it becomes available:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_web::body::MessageBody;
<span class="kw">use </span>actix_web::dev::{ServiceResponse, ServiceRequest};
<span class="kw">use </span>actix_web::{Error, HttpResponse};
<span class="kw">use </span>tracing_actix_web::{RootSpan, DefaultRootSpanBuilder, RootSpanBuilder};
<span class="kw">use </span>tracing::Span;
<span class="kw">use </span>actix_web::get;
<span class="kw">use </span>tracing_actix_web::RequestId;
<span class="kw">use </span>uuid::Uuid;

<span class="attr">#[get(<span class="string">&quot;/&quot;</span>)]
</span><span class="kw">async fn </span>handler(root_span: RootSpan) -&gt; HttpResponse {
    <span class="kw">let </span>application_id: <span class="kw-2">&amp;</span>str = <span class="macro">todo!</span>(<span class="string">&quot;Some domain logic&quot;</span>);
    <span class="comment">// Record the property value against the root span
    </span>root_span.record(<span class="string">&quot;application_id&quot;</span>, <span class="kw-2">&amp;</span>application_id);

    <span class="comment">// [...]
</span>}

<span class="kw">pub struct </span>DomainRootSpanBuilder;

<span class="kw">impl </span>RootSpanBuilder <span class="kw">for </span>DomainRootSpanBuilder {
    <span class="kw">fn </span>on_request_start(request: <span class="kw-2">&amp;</span>ServiceRequest) -&gt; Span {
        <span class="kw">let </span>client_id: <span class="kw-2">&amp;</span>str = <span class="macro">todo!</span>(<span class="string">&quot;Somehow extract it from the authorization header&quot;</span>);
        <span class="comment">// All fields you want to capture must be declared upfront.
        // If you don&#39;t know the value (yet), use tracing&#39;s `Empty`
        </span><span class="macro">tracing_actix_web::root_span!</span>(
            request,
            client_id, application_id = tracing::field::Empty
        )
    }

    <span class="kw">fn </span>on_request_end&lt;B: MessageBody&gt;(span: Span, response: <span class="kw-2">&amp;</span><span class="prelude-ty">Result</span>&lt;ServiceResponse&lt;B&gt;, Error&gt;) {
        DefaultRootSpanBuilder::on_request_end(span, response);
    }
}</code></pre></div>
<h2 id="unique-identifiers"><a href="#unique-identifiers">Unique identifiers</a></h2><h3 id="request-id"><a href="#request-id">Request Id</a></h3>
<p><code>tracing-actix-web</code> generates a unique identifier for each incoming request, the <strong>request id</strong>.</p>
<p>You can extract the request id using the <a href="struct.RequestId.html" title="struct tracing_actix_web::RequestId"><code>RequestId</code></a> extractor:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_web::get;
<span class="kw">use </span>tracing_actix_web::RequestId;
<span class="kw">use </span>uuid::Uuid;

<span class="attr">#[get(<span class="string">&quot;/&quot;</span>)]
</span><span class="kw">async fn </span>index(request_id: RequestId) -&gt; String {
    <span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, request_id)
}</code></pre></div>
<p>The request id is meant to identify all operations related to a particular request <strong>within the boundary of your API</strong>.
If you need to <strong>trace</strong> a request across multiple services (e.g. in a microservice architecture), you want to look at the <code>trace_id</code> field - see the next section on OpenTelemetry for more details.</p>
<p>Optionally, using the <code>uuid_v7</code> feature flag will allow <a href="struct.RequestId.html" title="struct tracing_actix_web::RequestId"><code>RequestId</code></a> to use UUID v7 instead of the currently used UUID v4.</p>
<p>However, the <a href="../uuid/index.html" title="mod uuid"><code>uuid</code></a> crate requires a compile time flag <code>uuid_unstable</code> to be passed in <code>RUSTFLAGS=&quot;--cfg uuid_unstable&quot;</code> in order to compile. You can read more about it <a href="https://docs.rs/uuid/latest/uuid/#unstable-features">here</a>.</p>
<h3 id="trace-id"><a href="#trace-id">Trace Id</a></h3>
<p>To fulfill a request you often have to perform additional I/O operations - e.g. calls to other REST or gRPC APIs, database queries, etc.
<strong>Distributed tracing</strong> is the standard approach to <strong>trace</strong> a single request across the entirety of your stack.</p>
<p><code>tracing-actix-web</code> provides support for distributed tracing by supporting the <a href="https://opentelemetry.io/">OpenTelemetry standard</a>.<br />
<code>tracing-actix-web</code> follows <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#spancontext">OpenTelemetry’s semantic convention</a>
for field names.
Furthermore, it provides an <code>opentelemetry_0_17</code> feature flag to automatically performs trace propagation: it tries to extract the OpenTelemetry context out of the headers of incoming requests and, when it finds one, it sets it as the remote context for the current root span. The context is then propagated to your downstream dependencies if your HTTP or gRPC clients are OpenTelemetry-aware - e.g. using <a href="https://github.com/TrueLayer/reqwest-middleware"><code>reqwest-middleware</code> and <code>reqwest-tracing</code></a> if you are using <code>reqwest</code> as your HTTP client.<br />
You can then find all logs for the same request across all the services it touched by looking for the <code>trace_id</code>, automatically logged by <code>tracing-actix-web</code>.</p>
<p>If you add <a href="https://docs.rs/tracing-opentelemetry/0.17.0/tracing_opentelemetry/struct.OpenTelemetryLayer.html"><code>tracing-opentelemetry::OpenTelemetryLayer</code></a>
in your <code>tracing::Subscriber</code> you will be able to export the root span (and all its children) as OpenTelemetry spans.</p>
<p>Check out the <a href="https://github.com/LukeMathWalker/tracing-actix-web/tree/main/examples/opentelemetry">relevant example in the GitHub repository</a> for reference.</p>
</div></details><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.root_span.html" title="macro tracing_actix_web::root_span">root_span</a></div><div class="desc docblock-short">[<code>root_span!</code>] creates a new <a href="../tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>tracing::Span</code></a>.
It empowers you to add custom properties to the root span on top of the HTTP properties tracked
by <a href="struct.DefaultRootSpanBuilder.html" title="struct tracing_actix_web::DefaultRootSpanBuilder"><code>DefaultRootSpanBuilder</code></a>.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.DefaultRootSpanBuilder.html" title="struct tracing_actix_web::DefaultRootSpanBuilder">DefaultRootSpanBuilder</a></div><div class="desc docblock-short">The default <a href="trait.RootSpanBuilder.html" title="trait tracing_actix_web::RootSpanBuilder"><code>RootSpanBuilder</code></a> for <a href="struct.TracingLogger.html" title="struct tracing_actix_web::TracingLogger"><code>TracingLogger</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Level.html" title="struct tracing_actix_web::Level">Level</a></div><div class="desc docblock-short">Describes the level of verbosity of a span or event.</div></li><li><div class="item-name"><a class="struct" href="struct.RequestId.html" title="struct tracing_actix_web::RequestId">RequestId</a></div><div class="desc docblock-short">A unique identifier generated for each incoming request.</div></li><li><div class="item-name"><a class="struct" href="struct.RootSpan.html" title="struct tracing_actix_web::RootSpan">RootSpan</a></div><div class="desc docblock-short">The root span associated to the in-flight current request.</div></li><li><div class="item-name"><a class="struct" href="struct.TracingLogger.html" title="struct tracing_actix_web::TracingLogger">TracingLogger</a></div><div class="desc docblock-short"><code>TracingLogger</code> is a middleware to capture structured diagnostic when processing an HTTP request.
Check the crate-level documentation for an in-depth introduction.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.RootSpanBuilder.html" title="trait tracing_actix_web::RootSpanBuilder">RootSpanBuilder</a></div><div class="desc docblock-short"><code>RootSpanBuilder</code> allows you to customise the root span attached by
<a href="struct.TracingLogger.html" title="struct tracing_actix_web::TracingLogger"><code>TracingLogger</code></a> to incoming requests.</div></li></ul></section></div></main></body></html>